#!/usr/bin/env python3
"""
Cycle OKE node pool workers by replacing their boot volumes.

The OCI documentation describes the behaviour where updating a node pool only
adjusts configuration for new nodes. Existing workers must be cycled (boot
volume replaced) to pick up the new image or Kubernetes version. This command
drives that workflow using the HTML report generated by ``oke_version_report``.
"""

from __future__ import annotations

import argparse
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

from rich.console import Console
from rich.logging import RichHandler

from oci import exceptions as oci_exceptions
from oci.container_engine.models import NodePoolCyclingDetails, UpdateNodePoolDetails

from oci_client.models import OKEClusterInfo, OKENodePoolInfo
from oci_client.utils.display import display_warning
from oci_client.utils.session import create_oci_client, setup_session_token
from oke_upgrade import ReportCluster, load_clusters_from_report, _ReportHTMLParser

console = Console()
logger = logging.getLogger(__name__)



@dataclass
class NodeCycleResult:
    """Outcome for cycling a node pool."""

    entry: ReportCluster
    node_pool_id: str
    node_pool_name: str
    status: str
    work_request_id: Optional[str]
    skipped: bool = False
    error: Optional[str] = None

    @property
    def success(self) -> bool:
        return (
            not self.skipped
            and self.error is None
            and self.status.upper() in {"SUCCEEDED", "IN_PROGRESS"}
        )


def _resolve_cluster_details(client: Any, cluster_id: str) -> OKEClusterInfo:
    """
    Retrieve cluster details either via the dedicated helper or by directly querying
    the Container Engine client (maintains compatibility with older client versions).
    """
    if hasattr(client, "get_oke_cluster"):
        return client.get_oke_cluster(cluster_id)  # type: ignore[attr-defined]

    ce_client = getattr(client, "container_engine_client", None)
    if ce_client is None:
        raise AttributeError("OCI client does not expose container_engine_client")

    cluster = ce_client.get_cluster(cluster_id).data
    available_upgrades_attr = getattr(cluster, "available_kubernetes_upgrades", None)
    if available_upgrades_attr is None:
        available_upgrades_attr = getattr(cluster, "available_upgrades", None)
    available_upgrades = list(available_upgrades_attr or [])

    return OKEClusterInfo(
        cluster_id=cluster_id,
        name=getattr(cluster, "name", cluster_id),
        kubernetes_version=getattr(cluster, "kubernetes_version", None),
        lifecycle_state=getattr(cluster, "lifecycle_state", None),
        compartment_id=getattr(cluster, "compartment_id", None),
        available_upgrades=available_upgrades,
    )


def _list_node_pools(client: Any, cluster_id: str, compartment_id: Optional[str]) -> List[OKENodePoolInfo]:
    """Retrieve node pools either via client helper or directly from the Container Engine API."""
    if hasattr(client, "list_node_pools"):
        return client.list_node_pools(cluster_id, compartment_id)  # type: ignore[attr-defined]

    ce_client = getattr(client, "container_engine_client", None)
    if ce_client is None:
        raise AttributeError("OCI client does not expose container_engine_client")

    request_kwargs: Dict[str, Any] = {"cluster_id": cluster_id}
    if compartment_id:
        request_kwargs["compartment_id"] = compartment_id

    response = ce_client.list_node_pools(**request_kwargs)
    data = getattr(response, "data", []) or []

    node_pools: List[OKENodePoolInfo] = []
    for pool in data:
        node_pool_id = getattr(pool, "id", None)
        if not node_pool_id:
            continue
        node_pools.append(
            OKENodePoolInfo(
                node_pool_id=node_pool_id,
                name=getattr(pool, "name", node_pool_id),
                kubernetes_version=getattr(pool, "kubernetes_version", None),
                lifecycle_state=getattr(pool, "lifecycle_state", None),
            )
        )
    return node_pools


def _fetch_node_pool_details(client: Any, node_pool_id: str) -> Any:
    ce_client = getattr(client, "container_engine_client", None)
    if ce_client is None:
        raise AttributeError("OCI client does not expose container_engine_client")
    return ce_client.get_node_pool(node_pool_id).data


def _extract_maximum_unavailable(node_pool_details: Any) -> int:
    details = getattr(node_pool_details, "node_pool_cycling_details", None)
    candidate = getattr(details, "maximum_unavailable", None) if details is not None else None
    if candidate in (None, "", 0):
        return 3
    try:
        value = int(candidate)
    except (TypeError, ValueError):
        logger.debug("Unable to parse maximum_unavailable=%r; defaulting to 3", candidate)
        return 3
    return max(value, 1)






def _cycle_node_pool(
    entry: ReportCluster,
    node_pool: OKENodePoolInfo,
    client: Any,
    *,
    grace_period: str,
    force_after_grace: bool,
    dry_run: bool,
    maximum_unavailable: int,
    maximum_surge: Optional[int],
    target_version: Optional[str],
) -> NodeCycleResult:
    ce_client = getattr(client, "container_engine_client", None)
    if ce_client is None:
        message = "OCI client does not expose container_engine_client"
        logger.error(message)
        return NodeCycleResult(
            entry=entry,
            node_pool_id=node_pool.node_pool_id,
            node_pool_name=node_pool.name,
            status="FAILED",
            work_request_id=None,
            error=message,
        )

    cycling_details = NodePoolCyclingDetails(
        is_node_cycling_enabled=True,
        cycle_modes=["BOOT_VOLUME_REPLACE"],
        maximum_unavailable=str(maximum_unavailable),
        maximum_surge=str(maximum_surge) if maximum_surge not in (None, "") else None,
    )

    if dry_run:
        logger.info(
            "[DRY RUN] Would enable boot-volume cycling for pool %s (%s) with maximum_unavailable=%s",
            node_pool.name,
            node_pool.node_pool_id,
            maximum_unavailable,
        )
        return NodeCycleResult(
            entry=entry,
            node_pool_id=node_pool.node_pool_id,
            node_pool_name=node_pool.name,
            status="DRY_RUN",
            work_request_id=None,
            skipped=True,
        )

    update_details = UpdateNodePoolDetails(
        kubernetes_version=target_version,
        node_pool_cycling_details=cycling_details,
    )

    logger.info(
        "Triggering boot-volume replace cycle for node pool %s (%s) in cluster %s (%s)",
        node_pool.name,
        node_pool.node_pool_id,
        entry.cluster_name,
        entry.cluster_ocid,
    )

    try:
        response = ce_client.update_node_pool(node_pool.node_pool_id, update_details)
    except oci_exceptions.ServiceError as exc:
        logger.error(
            "Failed to initiate cycling for node pool %s (%s): %s",
            node_pool.name,
            node_pool.node_pool_id,
            exc.message,
        )
        return NodeCycleResult(
            entry=entry,
            node_pool_id=node_pool.node_pool_id,
            node_pool_name=node_pool.name,
            status="FAILED",
            work_request_id=None,
            error=exc.message,
        )

    work_request_id = response.headers.get("opc-work-request-id")
    if work_request_id:
        console.print(
            f"[bold green]âœ“[/bold green] Cycle triggered for node pool [cyan]{node_pool.name}[/cyan] "
            f"({node_pool.node_pool_id}). Work request: [magenta]{work_request_id}[/magenta]"
        )
    else:
        console.print(
            f"[bold green]âœ“[/bold green] Cycle request submitted for node pool [cyan]{node_pool.name}[/cyan] "
            f"({node_pool.node_pool_id})."
        )

    return NodeCycleResult(
        entry=entry,
        node_pool_id=node_pool.node_pool_id,
        node_pool_name=node_pool.name,
        status="IN_PROGRESS" if work_request_id else "UNKNOWN",
        work_request_id=work_request_id,
    )


def perform_node_cycles(
    entries: Sequence[ReportCluster],
    *,
    grace_period: str,
    force_after_grace: bool,
    dry_run: bool,
) -> List[NodeCycleResult]:
    results: List[NodeCycleResult] = []
    clients: Dict[Tuple[str, str, str], Any] = {}

    for entry in entries:
        client_key = (entry.project, entry.stage, entry.region)
        if client_key not in clients:
            profile_name = setup_session_token(entry.project, entry.stage, entry.region)
            client = create_oci_client(entry.region, profile_name)
            if not client:
                message = (
                    f"Failed to initialize OCI client for {entry.project}/{entry.stage} in {entry.region}."
                )
                display_warning(message)
                results.append(
                    NodeCycleResult(
                        entry=entry,
                        node_pool_id="N/A",
                        node_pool_name="N/A",
                        status="FAILED",
                        work_request_id=None,
                        error=message,
                    )
                )
                continue
            clients[client_key] = client

        client = clients[client_key]
        try:
            cluster_info = _resolve_cluster_details(client, entry.cluster_ocid)
        except Exception as exc:  # pragma: no cover - defensive guard
            message = (
                f"Failed to resolve cluster details for {entry.cluster_name} "
                f"({entry.cluster_ocid}) in {entry.region}: {exc}"
            )
            display_warning(message)
            results.append(
                NodeCycleResult(
                    entry=entry,
                    node_pool_id="N/A",
                    node_pool_name="N/A",
                    status="FAILED",
                    work_request_id=None,
                    error=str(exc),
                )
            )
            continue

        if cluster_info.available_upgrades:
            display_warning(
                f"Cluster {entry.cluster_name} ({entry.cluster_ocid}) still lists available control "
                "plane upgrades. Complete the control plane upgrade and regenerate the report before cycling nodes."
            )

        try:
            node_pools = _list_node_pools(client, entry.cluster_ocid, cluster_info.compartment_id)
        except Exception as exc:  # pragma: no cover - defensive guard
            message = (
                f"Failed to list node pools for cluster {entry.cluster_name} "
                f"({entry.cluster_ocid}): {exc}"
            )
            display_warning(message)
            results.append(
                NodeCycleResult(
                    entry=entry,
                    node_pool_id="N/A",
                    node_pool_name="N/A",
                    status="FAILED",
                    work_request_id=None,
                    error=str(exc),
                )
            )
            continue

        for node_pool in node_pools:
            try:
                node_pool_details = _fetch_node_pool_details(client, node_pool.node_pool_id)
            except Exception as exc:  # pragma: no cover - defensive guard
                message = (
                    f"Failed to fetch node pool {node_pool.name} ({node_pool.node_pool_id}) details: {exc}"
                )
                display_warning(message)
                results.append(
                    NodeCycleResult(
                        entry=entry,
                        node_pool_id=node_pool.node_pool_id,
                        node_pool_name=node_pool.name,
                        status="FAILED",
                        work_request_id=None,
                        error=str(exc),
                    )
                )
                continue

            existing_cycling = getattr(node_pool_details, "node_pool_cycling_details", None)
            maximum_unavailable = _extract_maximum_unavailable(node_pool_details)
            maximum_surge = getattr(existing_cycling, "maximum_surge", None) if existing_cycling else None
            if maximum_surge not in (None, ""):
                try:
                    maximum_surge = int(maximum_surge)
                except (TypeError, ValueError):
                    logger.debug(
                        "Unable to parse maximum_surge=%r; keeping default (None)",
                        maximum_surge,
                    )
                    maximum_surge = None
            nodes = getattr(node_pool_details, "nodes", None) or []

            logger.info(
                "Node pool %s (%s) maximum_unavailable=%s maximum_surge=%s node_count=%s",
                node_pool.name,
                node_pool.node_pool_id,
                maximum_unavailable,
                maximum_surge,
                len(nodes),
            )

            target_version = (
                cluster_info.kubernetes_version
                or getattr(node_pool_details, "kubernetes_version", None)
            )

            result = _cycle_node_pool(
                entry,
                node_pool,
                client,
                grace_period=grace_period,
                force_after_grace=force_after_grace,
                dry_run=dry_run,
                maximum_unavailable=maximum_unavailable,
                maximum_surge=maximum_surge,
                target_version=target_version,
            )
            results.append(result)

    return results


def _summarize(results: Iterable[NodeCycleResult]) -> Tuple[int, int, int]:
    initiated = sum(1 for item in results if item.success)
    failures = sum(1 for item in results if not item.skipped and not item.success)
    skipped = sum(1 for item in results if item.skipped)
    return initiated, skipped, failures


def _diagnose_report(report_path: Path) -> List[str]:
    """Provide context when the HTML report does not produce any cluster entries."""
    diagnostics: List[str] = []
    try:
        parser = _ReportHTMLParser()
        html_content = report_path.read_text(encoding="utf-8")
        parser.feed(html_content)
    except Exception as exc:  # pragma: no cover - defensive
        return [f"Failed to parse report {report_path}: {exc}"]

    total_rows = len(parser.rows)
    if total_rows == 0:
        diagnostics.append(
            "Report parser did not find any <tbody> rows. Ensure the report was generated with the latest tooling."
        )
        return diagnostics

    diagnostics.append(f"Report parser captured {total_rows} row(s).")

    short_rows: List[Tuple[int, int, List[str]]] = []
    for idx, row in enumerate(parser.rows, start=1):
        if len(row) < 9:
            short_rows.append((idx, len(row), row))

    if short_rows:
        diagnostics.append(
            "The following row(s) contain fewer than 9 columns (project/stage/region/... columns are required):"
        )
        for idx, length, row in short_rows[:5]:
            sample = ", ".join(row[: min(len(row), 4)])
            diagnostics.append(f"  Row {idx}: {length} column(s). Sample data: {sample}")
        if len(short_rows) > 5:
            diagnostics.append(f"  â€¦ {len(short_rows) - 5} additional row(s) omitted.")
    else:
        diagnostics.append("All parsed rows have the expected number of columns.")

    return diagnostics


def configure_logging(verbose: bool = False) -> None:
    logging.basicConfig(
        level=logging.DEBUG if verbose else logging.INFO,
        format="%(message)s",
        handlers=[RichHandler(rich_tracebacks=True)],
    )


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Cycle OKE node pools to replace worker boot volumes based on an HTML report.",
    )
    parser.add_argument("report_path", help="Path to the HTML report generated by oke_version_report.")
    parser.add_argument(
        "--grace-period",
        default="PT30M",
        help="Eviction grace period in ISO-8601 duration format (default: PT30M).",
    )
    parser.add_argument(
        "--force-after-grace",
        action="store_true",
        help="Force deletion after the grace period elapses.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show planned node cycles without calling OCI APIs.",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug logging.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_arguments()
    configure_logging(verbose=args.verbose)

    report_path = Path(args.report_path).expanduser().resolve()
    if not report_path.exists():
        console.print(f"[bold red]âœ— Report not found:[/bold red] {report_path}")
        return 1

    entries = load_clusters_from_report(report_path)
    if not entries:
        console.print("[bold red]âœ— No clusters found in the provided report.[/bold red]")
        for line in _diagnose_report(report_path):
            console.print(f"[dim]- {line}[/dim]")
        return 1

    console.print("ðŸš€ Initiating OKE node cycling workflow...")
    console.print(f"ðŸ“„ Using report: {report_path}")

    results = perform_node_cycles(
        entries,
        grace_period=args.grace_period,
        force_after_grace=args.force_after_grace,
        dry_run=args.dry_run,
    )

    initiated, skipped, failures = _summarize(results)
    console.print(
        f"Summary: initiated {initiated} cycle(s); {skipped} skipped; {failures} failure(s)."
    )

    return 0 if failures == 0 else 1


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
